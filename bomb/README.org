#+TITLE: CS:APP Bomb disposal specialist
#+OPTIONS: toc:nil ^:nil

* Intro

To start this journey, you should have some equipment.
Following are essential:
#+begin_example
0. *WARNING*: Please run all the commands under GNU/Linux, other platforms
              haven't been tested.
1. GDB: The GNU Project Debugger, Please use the 64-bit version.
        In this tour, I will use GNU gdb 11.1 overall.
2. objdump: Display information from object files.
#+end_example

Here is the source code of C =bomb.c= without head information:
#+begin_src c
  #include <stdio.h>
  #include <stdlib.h>
  #include "support.h"
  #include "phases.h"

  /*
   ,* Note to self: Remember to erase this file so my victims will have no
   ,* idea what is going on, and so they will all blow up in a
   ,* spectaculary fiendish explosion. -- Dr. Evil
   ,*/

  FILE *infile;

  int main(int argc, char *argv[])
  {
      char *input;

      /* Note to self: remember to port this bomb to Windows and put a
       ,* fantastic GUI on it. */

      /* When run with no arguments, the bomb reads its input lines
       ,* from standard input. */
      if (argc == 1) {
          infile = stdin;
      }

      /* When run with one argument <file>, the bomb reads from <file>
       ,* until EOF, and then switches to standard input. Thus, as you
       ,* defuse each phase, you can add its defusing string to <file> and
       ,* avoid having to retype it. */
      else if (argc == 2) {
          if (!(infile = fopen(argv[1], "r"))) {
              printf("%s: Error: Couldn't open %s\n", argv[0], argv[1]);
              exit(8);
          }
      }

      /* You can't call the bomb with more than 1 command line argument. */
      else {
          printf("Usage: %s [<input_file>]\n", argv[0]);
          exit(8);
      }

      /* Do all sorts of secret stuff that makes the bomb harder to defuse. */
      initialize_bomb();

      printf("Welcome to my fiendish little bomb. You have 6 phases with\n");
      printf("which to blow yourself up. Have a nice day!\n");

      /* Hmm...  Six phases must be more secure than one phase! */
      input = read_line();             /* Get input                   */
      phase_1(input);                  /* Run the phase               */
      phase_defused();                 /* Drat!  They figured it out!
                                        ,* Let me know how they did it. */
      printf("Phase 1 defused. How about the next one?\n");

      /* The second phase is harder.  No one will ever figure out
       ,* how to defuse this... */
      input = read_line();
      phase_2(input);
      phase_defused();
      printf("That's number 2.  Keep going!\n");

      /* I guess this is too easy so far.  Some more complex code will
       ,* confuse people. */
      input = read_line();
      phase_3(input);
      phase_defused();
      printf("Halfway there!\n");

      /* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */
      input = read_line();
      phase_4(input);
      phase_defused();
      printf("So you got that one.  Try this one.\n");

      /* Round and 'round in memory we go, where we stop, the bomb blows! */
      input = read_line();
      phase_5(input);
      phase_defused();
      printf("Good work!  On to the next...\n");

      /* This phase will never be used, since no one will get past the
       ,* earlier ones.  But just in case, make this one extra hard. */
      input = read_line();
      phase_6(input);
      phase_defused();

      /* Wow, they got it!  But isn't something... missing?  Perhaps
       ,* something they overlooked?  Mua ha ha ha ha! */

      return 0;
  }

#+end_src

At the very beginning of this adventure, we need disassemble the
binary file first.
#+begin_src sh
    # bash-5.1$ cd bomb/
    # bash-5.1$ ls
    # README	README.html  README.org  bomb  bomb.c
    # bash-5.1$ objdump -dS bomb > bomb.s

    cd /path/to/bomb/
    objdump -dS bomb > bomb.s
#+end_src

Then you will get =bomb.s= like this:
#+begin_src asm

  bomb:     file format elf64-x86-64


  Disassembly of section .init:

  0000000000400ac0 <_init>:
    400ac0:	48 83 ec 08             sub    $0x8,%rsp
    400ac4:	e8 f3 01 00 00          callq  400cbc <call_gmon_start>
    400ac9:	48 83 c4 08             add    $0x8,%rsp
    400acd:	c3                      retq
          .
          .
          .

  Disassembly of section .plt:

  0000000000400ad0 <.plt>:
    400ad0:	ff 35 1a 25 20 00       pushq  0x20251a(%rip)        # 602ff0 <_GLOBAL_OFFSET_TABLE_+0x8>
    400ad6:	ff 25 1c 25 20 00       jmpq   *0x20251c(%rip)        # 602ff8 <_GLOBAL_OFFSET_TABLE_+0x10>
    400adc:	0f 1f 40 00             nopl   0x0(%rax)
          .
          .
          .

  Disassembly of section .text:

  0000000000400c90 <_start>:
    400c90:	31 ed                   xor    %ebp,%ebp
    400c92:	49 89 d1                mov    %rdx,%r9
    400c95:	5e                      pop    %rsi
    400c96:	48 89 e2                mov    %rsp,%rdx
    400c99:	48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
    400c9d:	50                      push   %rax
    400c9e:	54                      push   %rsp
    400c9f:	49 c7 c0 a0 22 40 00    mov    $0x4022a0,%r8
    400ca6:	48 c7 c1 10 22 40 00    mov    $0x402210,%rcx
    400cad:	48 c7 c7 a0 0d 40 00    mov    $0x400da0,%rdi
    400cb4:	e8 b7 fe ff ff          callq  400b70 <__libc_start_main@plt>
    400cb9:	f4                      hlt
    400cba:	90                      nop
    400cbb:	90                      nop
          .
          .
          .

  Disassembly of section .fini:

  00000000004022a4 <_fini>:
    4022a4:	48 83 ec 08             sub    $0x8,%rsp
    4022a8:	48 83 c4 08             add    $0x8,%rsp
    4022ac:	c3                      retq

#+end_src

* Adventure start

** Bomb 1

First of all, let's expose the bomb-1's code in =bomb.c=:
#+begin_src c
  char *input;

  /* Do all sorts of secret stuff that makes the bomb harder to defuse. */
  initialize_bomb();

  /* Hmm...  Six phases must be more secure than one phase! */
  input = read_line();             /* Get input                   */
  phase_1(input);                  /* Run the phase               */
  phase_defused();                 /* Drat!  They figured it out!
                                    ,* Let me know how they did it. */
  printf("Phase 1 defused. How about the next one?\n");
#+end_src

Here we can notice that =phase_1(input)= is the core function of bomb-1.

Next, what about =phase_1(char *)= assembly code looks like(in call order)?
#+begin_src asm
  0000000000400da0 <main>:
    400e32:	e8 67 06 00 00          callq  40149e <read_line>
    400e37:	48 89 c7                mov    %rax,%rdi ; input -> %rdi
    400e3a:	e8 a1 00 00 00          callq  400ee0 <phase_1> ; still
    400e3f:	e8 80 07 00 00          callq  4015c4 <phase_defused>
    400e44:	bf a8 23 40 00          mov    $0x4023a8,%edi
    400e49:	e8 c2 fc ff ff          callq  400b10 <puts@plt>

  0000000000400ee0 <phase_1>:
    400ee0:	48 83 ec 08             sub    $0x8,%rsp
    400ee4:	be 00 24 40 00          mov    $0x402400,%esi ; phase 1
    400ee9:	e8 4a 04 00 00          callq  401338 <strings_not_equal>
    400eee:	85 c0                   test   %eax,%eax
    400ef0:	74 05                   je     400ef7 <phase_1+0x17>
    400ef2:	e8 43 05 00 00          callq  40143a <explode_bomb>
    400ef7:	48 83 c4 08             add    $0x8,%rsp
    400efb:	c3                      retq

  0000000000401338 <strings_not_equal>:
    401338:	41 54                   push   %r12
    40133a:	55                      push   %rbp
    40133b:	53                      push   %rbx
    40133c:	48 89 fb                mov    %rdi,%rbx ; input
    40133f:	48 89 f5                mov    %rsi,%rbp
    401342:	e8 d4 ff ff ff          callq  40131b <string_length>
    401347:	41 89 c4                mov    %eax,%r12d ; input's length
    40134a:	48 89 ef                mov    %rbp,%rdi
    40134d:	e8 c9 ff ff ff          callq  40131b <string_length>
    401352:	ba 01 00 00 00          mov    $0x1,%edx
    401357:	41 39 c4                cmp    %eax,%r12d
    40135a:	75 3f                   jne    40139b <strings_not_equal+0x63>
    40135c:	0f b6 03                movzbl (%rbx),%eax
    40135f:	84 c0                   test   %al,%al
    401361:	74 25                   je     401388 <strings_not_equal+0x50>
    401363:	3a 45 00                cmp    0x0(%rbp),%al
    401366:	74 0a                   je     401372 <strings_not_equal+0x3a>
    401368:	eb 25                   jmp    40138f <strings_not_equal+0x57>
    40136a:	3a 45 00                cmp    0x0(%rbp),%al
    40136d:	0f 1f 00                nopl   (%rax)
    401370:	75 24                   jne    401396 <strings_not_equal+0x5e>
    401372:	48 83 c3 01             add    $0x1,%rbx
    401376:	48 83 c5 01             add    $0x1,%rbp
    40137a:	0f b6 03                movzbl (%rbx),%eax
    40137d:	84 c0                   test   %al,%al
    40137f:	75 e9                   jne    40136a <strings_not_equal+0x32>
    401381:	ba 00 00 00 00          mov    $0x0,%edx
    401386:	eb 13                   jmp    40139b <strings_not_equal+0x63>
    401388:	ba 00 00 00 00          mov    $0x0,%edx
    40138d:	eb 0c                   jmp    40139b <strings_not_equal+0x63>
    40138f:	ba 01 00 00 00          mov    $0x1,%edx
    401394:	eb 05                   jmp    40139b <strings_not_equal+0x63>
    401396:	ba 01 00 00 00          mov    $0x1,%edx
    40139b:	89 d0                   mov    %edx,%eax
    40139d:	5b                      pop    %rbx
    40139e:	5d                      pop    %rbp
    40139f:	41 5c                   pop    %r12
    4013a1:	c3                      retq

  000000000040131b <string_length>:
    40131b:	80 3f 00                cmpb   $0x0,(%rdi)
    40131e:	74 12                   je     401332 <string_length+0x17>
    401320:	48 89 fa                mov    %rdi,%rdx
    401323:	48 83 c2 01             add    $0x1,%rdx
    401327:	89 d0                   mov    %edx,%eax
    401329:	29 f8                   sub    %edi,%eax
    40132b:	80 3a 00                cmpb   $0x0,(%rdx)
    40132e:	75 f3                   jne    401323 <string_length+0x8>
    401330:	f3 c3                   repz retq
    401332:	b8 00 00 00 00          mov    $0x0,%eax
    401337:	c3                      retq
#+end_src

Analyzing above code blocks, we found that register %rax stored the secret of bomb-1.\\
To make sense of what does %rax stored, we need GDB now!
#+begin_example
  bash-5.1$ ls
  README  README.org  bomb  bomb.c  bomb.s
  bash-5.1$ gdb --tui bomb
  ┌─bomb.c───────────────────────────────────────────────────────────────────────────────────────────────────────┐
  │       28  /*                                                                                                 │
  │       29   * Note to self: Remember to erase this file so my victims will have no                            │
  │       30   * idea what is going on, and so they will all blow up in a                                        │
  │       31   * spectaculary fiendish explosion. -- Dr. Evil                                                    │
  │       32   */                                                                                                │
  │       33                                                                                                     │
  │       34  FILE *infile;                                                                                      │
  │       35                                                                                                     │
  │       36  int main(int argc, char *argv[])                                                                   │
  │       37  {                                                                                                  │
  │       38      char *input;                                                                                   │
  │       39                                                                                                     │
  │       40      /* Note to self: remember to port this bomb to Windows and put a                               │
  │       41       * fantastic GUI on it. */                                                                     │
  │       42                                                                                                     │
  │       43      /* When run with no arguments, the bomb reads its input lines                                  │
  └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
  exec No process In:                                                                                L??   PC: ??
  --Type <RET> for more, q to quit, c to continue without paging--For bug reporting instructions, please see:
  <https://bugs.gentoo.org/>.
  Find the GDB manual and other documentation resources online at:
      <http://www.gnu.org/software/gdb/documentation/>.

  For help, type "help".
  Type "apropos word" to search for commands related to "word"...
  Reading symbols from bomb...
  (gdb) l 72
  (gdb) b 74
  Breakpoint 1 at 0x400e37: file bomb.c, line 74.
  (gdb) r
  Welcome to my fiendish little bomb. You have 6 phases with
  which to blow yourself up. Have a nice day!
  Just for guessing, don't take it seriously!

  ┌─bomb.c───────────────────────────────────────────────────────────────────────────────────────────────────────┐
  │       71                                                                                                     │
  │       72      /* Hmm...  Six phases must be more secure than one phase! */                                   │
  │       73      input = read_line();             /* Get input                   */                             │
  │       74      phase_1(input);                  /* Run the phase               */                             │
  │       75      phase_defused();                 /* Drat!  They figured it out!                                │
  │       76                                        * Let me know how they did it. */                            │
  │       77      printf("Phase 1 defused. How about the next one?\n");                                          │
  │       78                                                                                                     │
  │  >    79      phase_1(input);                  /* Run the phase               */                             │
  │       80       * how to defuse this... */                                                                    │
  │       81      input = read_line();                                                                           │
  │       82      phase_2(input);                                                                                │
  └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
  exec No process In:                                                                                L??   PC: ??
  For help, type "help".
  Type "apropos word" to search for commands related to "word"...
  native process 6289 In: main
  Breakpoint 1 at 0x400e37: file bomb.c, line 74.
  (gdb) r
  Welcome to my fiendish little bomb. You have 6 phases with
  which to blow yourself up. Have a nice day!
  Just for guessing, don't take it seriously!

  Breakpoint 1, main (argc=<optimized out>, argv=<optimized out>) at bomb.c:74

  (gdb) x $rax
  0x603780 <input_strings>:	0x7473754a
  (gdb) x/sb $rax
  0x603780 <input_strings>:	"Just for guessing, don't take it seriously!"
  (gdb) disassemble
  Dump of assembler code for function main:
     0x0000000000400da0 <+0>:	push   %rbx
     0x0000000000400da1 <+1>:	cmp    $0x1,%edi
     0x0000000000400da4 <+4>:	jne    0x400db6 <main+22>
     0x0000000000400da6 <+6>:	mov    0x20299b(%rip),%rax        # 0x603748 <stdin@@GLIBC_2.2.5>
     0x0000000000400dad <+13>:	mov    %rax,0x2029b4(%rip)        # 0x603768 <infile>
     0x0000000000400db4 <+20>:	jmp    0x400e19 <main+121>
     0x0000000000400db6 <+22>:	mov    %rsi,%rbx
     0x0000000000400db9 <+25>:	cmp    $0x2,%edi
     0x0000000000400dbc <+28>:	jne    0x400df8 <main+88>
     0x0000000000400dbe <+30>:	mov    0x8(%rsi),%rdi
     0x0000000000400dc2 <+34>:	mov    $0x4022b4,%esi
     0x0000000000400dc7 <+39>:	call   0x400c10 <fopen@plt>
     0x0000000000400dcc <+44>:	mov    %rax,0x202995(%rip)        # 0x603768 <infile>
     0x0000000000400dd3 <+51>:	test   %rax,%rax
     0x0000000000400dd6 <+54>:	jne    0x400e19 <main+121>
     0x0000000000400dd8 <+56>:	mov    0x8(%rbx),%rcx
     0x0000000000400ddc <+60>:	mov    (%rbx),%rdx
     0x0000000000400ddf <+63>:	mov    $0x4022b6,%esi
     0x0000000000400de4 <+68>:	mov    $0x1,%edi
     0x0000000000400de9 <+73>:	call   0x400c00 <__printf_chk@plt>
     0x0000000000400dee <+78>:	mov    $0x8,%edi
     0x0000000000400df3 <+83>:	call   0x400c20 <exit@plt>
     0x0000000000400df8 <+88>:	mov    (%rsi),%rdx
     0x0000000000400dfb <+91>:	mov    $0x4022d3,%esi
     0x0000000000400e00 <+96>:	mov    $0x1,%edi
     0x0000000000400e05 <+101>:	mov    $0x0,%eax
     0x0000000000400e0a <+106>:	call   0x400c00 <__printf_chk@plt>
     0x0000000000400e0f <+111>:	mov    $0x8,%edi
     0x0000000000400e14 <+116>:	call   0x400c20 <exit@plt>
     0x0000000000400e19 <+121>:	call   0x4013a2 <initialize_bomb>
     0x0000000000400e1e <+126>:	mov    $0x402338,%edi
     0x0000000000400e23 <+131>:	call   0x400b10 <puts@plt>
     0x0000000000400e28 <+136>:	mov    $0x402378,%edi
     0x0000000000400e2d <+141>:	call   0x400b10 <puts@plt>
     0x0000000000400e32 <+146>:	call   0x40149e <read_line>
  => 0x0000000000400e37 <+151>:	mov    %rax,%rdi
     0x0000000000400e3a <+154>:	call   0x400ee0 <phase_1>
     0x0000000000400e3f <+159>:	call   0x4015c4 <phase_defused>
     0x0000000000400e44 <+164>:	mov    $0x4023a8,%edi
     0x0000000000400e49 <+169>:	call   0x400b10 <puts@plt>
     0x0000000000400e4e <+174>:	call   0x40149e <read_line>
     0x0000000000400e53 <+179>:	mov    %rax,%rdi
     0x0000000000400e56 <+182>:	call   0x400efc <phase_2>
     0x0000000000400e5b <+187>:	call   0x4015c4 <phase_defused>
     0x0000000000400e60 <+192>:	mov    $0x4022ed,%edi
     0x0000000000400e65 <+197>:	call   0x400b10 <puts@plt>
     0x0000000000400e6a <+202>:	call   0x40149e <read_line>
     0x0000000000400e6f <+207>:	mov    %rax,%rdi
     0x0000000000400e72 <+210>:	call   0x400f43 <phase_3>
     0x0000000000400e77 <+215>:	call   0x4015c4 <phase_defused>
     0x0000000000400e7c <+220>:	mov    $0x40230b,%edi
     0x0000000000400e81 <+225>:	call   0x400b10 <puts@plt>
     0x0000000000400e86 <+230>:	call   0x40149e <read_line>
     0x0000000000400e8b <+235>:	mov    %rax,%rdi
     0x0000000000400e8e <+238>:	call   0x40100c <phase_4>
     0x0000000000400e93 <+243>:	call   0x4015c4 <phase_defused>
     0x0000000000400e98 <+248>:	mov    $0x4023d8,%edi
     0x0000000000400e9d <+253>:	call   0x400b10 <puts@plt>
     0x0000000000400ea2 <+258>:	call   0x40149e <read_line>
     0x0000000000400ea7 <+263>:	mov    %rax,%rdi
     0x0000000000400eaa <+266>:	call   0x401062 <phase_5>
     0x0000000000400eaf <+271>:	call   0x4015c4 <phase_defused>
     0x0000000000400eb4 <+276>:	mov    $0x40231a,%edi
     0x0000000000400eb9 <+281>:	call   0x400b10 <puts@plt>
     0x0000000000400ebe <+286>:	call   0x40149e <read_line>
     0x0000000000400ec3 <+291>:	mov    %rax,%rdi
     0x0000000000400ec6 <+294>:	call   0x4010f4 <phase_6>
     0x0000000000400ecb <+299>:	call   0x4015c4 <phase_defused>
     0x0000000000400ed0 <+304>:	mov    $0x0,%eax
     0x0000000000400ed5 <+309>:	pop    %rbx
     0x0000000000400ed6 <+310>:	ret
  End of assembler dump.
  (gdb) si
  0x0000000000400e3a	74	    phase_1(input);                  /* Run the phase               */
  (gdb) si
  0x0000000000400ee0 in phase_1 ()
  (gdb) bt
  #0  0x0000000000400ee0 in phase_1 ()
  #1  0x0000000000400e3f in main (argc=<optimized out>, argv=<optimized out>) at bomb.c:74
  (gdb) disassemble
  Dump of assembler code for function phase_1:
  => 0x0000000000400ee0 <+0>:	sub    $0x8,%rsp
     0x0000000000400ee4 <+4>:	mov    $0x402400,%esi
     0x0000000000400ee9 <+9>:	call   0x401338 <strings_not_equal>
     0x0000000000400eee <+14>:	test   %eax,%eax
     0x0000000000400ef0 <+16>:	je     0x400ef7 <phase_1+23>
     0x0000000000400ef2 <+18>:	call   0x40143a <explode_bomb>
     0x0000000000400ef7 <+23>:	add    $0x8,%rsp
     0x0000000000400efb <+27>:	ret
  End of assembler dump.
  (gdb) si
  0x0000000000400ee4 in phase_1 ()
  (gdb) bt
  #0  0x0000000000400ee4 in phase_1 ()
  #1  0x0000000000400e3f in main (argc=<optimized out>, argv=<optimized out>) at bomb.c:74
  (gdb) si
  0x0000000000400ee9 in phase_1 ()
  (gdb) x/sb $esi
  0x402400:	"Border relations with Canada have never been better."
  (gdb) x/sb $rdi
  0x603780 <input_strings>:	"Just for guessing, don't take it seriously!"
  (gdb) si
  0x0000000000401338 in strings_not_equal ()
  (gdb) bt
  #0  0x0000000000401338 in strings_not_equal ()
  #1  0x0000000000400eee in phase_1 ()
  #2  0x0000000000400e3f in main (argc=<optimized out>, argv=<optimized out>) at bomb.c:74
  (gdb) disassemble
  Dump of assembler code for function strings_not_equal:
  => 0x0000000000401338 <+0>:	push   %r12
     0x000000000040133a <+2>:	push   %rbp
     0x000000000040133b <+3>:	push   %rbx
     0x000000000040133c <+4>:	mov    %rdi,%rbx
     0x000000000040133f <+7>:	mov    %rsi,%rbp
     0x0000000000401342 <+10>:	call   0x40131b <string_length>
     0x0000000000401347 <+15>:	mov    %eax,%r12d
     0x000000000040134a <+18>:	mov    %rbp,%rdi
     0x000000000040134d <+21>:	call   0x40131b <string_length>
     0x0000000000401352 <+26>:	mov    $0x1,%edx
     0x0000000000401357 <+31>:	cmp    %eax,%r12d
     0x000000000040135a <+34>:	jne    0x40139b <strings_not_equal+99>
     0x000000000040135c <+36>:	movzbl (%rbx),%eax
     0x000000000040135f <+39>:	test   %al,%al
     0x0000000000401361 <+41>:	je     0x401388 <strings_not_equal+80>
     0x0000000000401363 <+43>:	cmp    0x0(%rbp),%al
     0x0000000000401366 <+46>:	je     0x401372 <strings_not_equal+58>
     0x0000000000401368 <+48>:	jmp    0x40138f <strings_not_equal+87>
     0x000000000040136a <+50>:	cmp    0x0(%rbp),%al
     0x000000000040136d <+53>:	nopl   (%rax)
     0x0000000000401370 <+56>:	jne    0x401396 <strings_not_equal+94>
     0x0000000000401372 <+58>:	add    $0x1,%rbx
     0x0000000000401376 <+62>:	add    $0x1,%rbp
     0x000000000040137a <+66>:	movzbl (%rbx),%eax
     0x000000000040137d <+69>:	test   %al,%al
     0x000000000040137f <+71>:	jne    0x40136a <strings_not_equal+50>
     0x0000000000401381 <+73>:	mov    $0x0,%edx
     0x0000000000401386 <+78>:	jmp    0x40139b <strings_not_equal+99>
     0x0000000000401388 <+80>:	mov    $0x0,%edx
     0x000000000040138d <+85>:	jmp    0x40139b <strings_not_equal+99>
     0x000000000040138f <+87>:	mov    $0x1,%edx
     0x0000000000401394 <+92>:	jmp    0x40139b <strings_not_equal+99>
     0x0000000000401396 <+94>:	mov    $0x1,%edx
     0x000000000040139b <+99>:	mov    %edx,%eax
     0x000000000040139d <+101>:	pop    %rbx
     0x000000000040139e <+102>:	pop    %rbp
     0x000000000040139f <+103>:	pop    %r12
     0x00000000004013a1 <+105>:	ret
  End of assembler dump.
  (gdb) si
  0x000000000040133a in strings_not_equal ()
  (gdb)
  0x000000000040133b in strings_not_equal ()
  (gdb)
  0x000000000040133c in strings_not_equal ()
  (gdb) disassemble
  (gdb) si
  0x000000000040133f in strings_not_equal ()
  (gdb)
  0x0000000000401342 in strings_not_equal ()
  (gdb)
  0x000000000040131b in string_length ()
  (gdb) f
  #0  0x000000000040131b in string_length ()
  (gdb) disassemble
  Dump of assembler code for function string_length:
  => 0x000000000040131b <+0>:	cmpb   $0x0,(%rdi)
     0x000000000040131e <+3>:	je     0x401332 <string_length+23>
     0x0000000000401320 <+5>:	mov    %rdi,%rdx
     0x0000000000401323 <+8>:	add    $0x1,%rdx
     0x0000000000401327 <+12>:	mov    %edx,%eax
     0x0000000000401329 <+14>:	sub    %edi,%eax
     0x000000000040132b <+16>:	cmpb   $0x0,(%rdx)
     0x000000000040132e <+19>:	jne    0x401323 <string_length+8>
     0x0000000000401330 <+21>:	repz ret
     0x0000000000401332 <+23>:	mov    $0x0,%eax
     0x0000000000401337 <+28>:	ret
  End of assembler dump.
  (gdb) finish
  Run till exit from #0  0x000000000040131b in string_length ()
  0x0000000000401347 in strings_not_equal ()
  (gdb) p $eax
  $2 = 43
  (gdb) si
  0x000000000040134a in strings_not_equal ()
  (gdb) disassemble
  Dump of assembler code for function strings_not_equal:
     0x0000000000401338 <+0>:	push   %r12
     0x000000000040133a <+2>:	push   %rbp
     0x000000000040133b <+3>:	push   %rbx
     0x000000000040133c <+4>:	mov    %rdi,%rbx
     0x000000000040133f <+7>:	mov    %rsi,%rbp
     0x0000000000401342 <+10>:	call   0x40131b <string_length>
     0x0000000000401347 <+15>:	mov    %eax,%r12d
  => 0x000000000040134a <+18>:	mov    %rbp,%rdi
     0x000000000040134d <+21>:	call   0x40131b <string_length>
     0x0000000000401352 <+26>:	mov    $0x1,%edx
     0x0000000000401357 <+31>:	cmp    %eax,%r12d
     0x000000000040135a <+34>:	jne    0x40139b <strings_not_equal+99>
     0x000000000040135c <+36>:	movzbl (%rbx),%eax
     0x000000000040135f <+39>:	test   %al,%al
     0x0000000000401361 <+41>:	je     0x401388 <strings_not_equal+80>
     0x0000000000401363 <+43>:	cmp    0x0(%rbp),%al
     0x0000000000401366 <+46>:	je     0x401372 <strings_not_equal+58>
     0x0000000000401368 <+48>:	jmp    0x40138f <strings_not_equal+87>
     0x000000000040136a <+50>:	cmp    0x0(%rbp),%al
     0x000000000040136d <+53>:	nopl   (%rax)
     0x0000000000401370 <+56>:	jne    0x401396 <strings_not_equal+94>
     0x0000000000401372 <+58>:	add    $0x1,%rbx
     0x0000000000401376 <+62>:	add    $0x1,%rbp
     0x000000000040137a <+66>:	movzbl (%rbx),%eax
     0x000000000040137d <+69>:	test   %al,%al
     0x000000000040137f <+71>:	jne    0x40136a <strings_not_equal+50>
     0x0000000000401381 <+73>:	mov    $0x0,%edx
     0x0000000000401386 <+78>:	jmp    0x40139b <strings_not_equal+99>
     0x0000000000401388 <+80>:	mov    $0x0,%edx
     0x000000000040138d <+85>:	jmp    0x40139b <strings_not_equal+99>
     0x000000000040138f <+87>:	mov    $0x1,%edx
     0x0000000000401394 <+92>:	jmp    0x40139b <strings_not_equal+99>
     0x0000000000401396 <+94>:	mov    $0x1,%edx
     0x000000000040139b <+99>:	mov    %edx,%eax
     0x000000000040139d <+101>:	pop    %rbx
     0x000000000040139e <+102>:	pop    %rbp
     0x000000000040139f <+103>:	pop    %r12
     0x00000000004013a1 <+105>:	ret
  End of assembler dump.
  (gdb) si
  0x000000000040134d in strings_not_equal ()
  (gdb)
  0x000000000040131b in string_length ()
  (gdb) disassemble
  Dump of assembler code for function string_length:
  => 0x000000000040131b <+0>:	cmpb   $0x0,(%rdi)
     0x000000000040131e <+3>:	je     0x401332 <string_length+23>
     0x0000000000401320 <+5>:	mov    %rdi,%rdx
     0x0000000000401323 <+8>:	add    $0x1,%rdx
     0x0000000000401327 <+12>:	mov    %edx,%eax
     0x0000000000401329 <+14>:	sub    %edi,%eax
     0x000000000040132b <+16>:	cmpb   $0x0,(%rdx)
     0x000000000040132e <+19>:	jne    0x401323 <string_length+8>
     0x0000000000401330 <+21>:	repz ret
     0x0000000000401332 <+23>:	mov    $0x0,%eax
     0x0000000000401337 <+28>:	ret
  End of assembler dump.
  (gdb) bt
  #0  0x000000000040131b in string_length ()
  #1  0x0000000000401352 in strings_not_equal ()
  #2  0x0000000000400eee in phase_1 ()
  #3  0x0000000000400e3f in main (argc=<optimized out>, argv=<optimized out>) at bomb.c:74
  (gdb) finish
  Run till exit from #0  0x000000000040131b in string_length ()
  0x0000000000401352 in strings_not_equal ()
  (gdb) disassemble
  Dump of assembler code for function strings_not_equal:
     0x0000000000401338 <+0>:	push   %r12
     0x000000000040133a <+2>:	push   %rbp
     0x000000000040133b <+3>:	push   %rbx
     0x000000000040133c <+4>:	mov    %rdi,%rbx
     0x000000000040133f <+7>:	mov    %rsi,%rbp
     0x0000000000401342 <+10>:	call   0x40131b <string_length>
     0x0000000000401347 <+15>:	mov    %eax,%r12d
     0x000000000040134a <+18>:	mov    %rbp,%rdi
     0x000000000040134d <+21>:	call   0x40131b <string_length>
  => 0x0000000000401352 <+26>:	mov    $0x1,%edx
     0x0000000000401357 <+31>:	cmp    %eax,%r12d
     0x000000000040135a <+34>:	jne    0x40139b <strings_not_equal+99>
     0x000000000040135c <+36>:	movzbl (%rbx),%eax
     0x000000000040135f <+39>:	test   %al,%al
     0x0000000000401361 <+41>:	je     0x401388 <strings_not_equal+80>
     0x0000000000401363 <+43>:	cmp    0x0(%rbp),%al
     0x0000000000401366 <+46>:	je     0x401372 <strings_not_equal+58>
     0x0000000000401368 <+48>:	jmp    0x40138f <strings_not_equal+87>
     0x000000000040136a <+50>:	cmp    0x0(%rbp),%al
     0x000000000040136d <+53>:	nopl   (%rax)
     0x0000000000401370 <+56>:	jne    0x401396 <strings_not_equal+94>
     0x0000000000401372 <+58>:	add    $0x1,%rbx
     0x0000000000401376 <+62>:	add    $0x1,%rbp
     0x000000000040137a <+66>:	movzbl (%rbx),%eax
     0x000000000040137d <+69>:	test   %al,%al
     0x000000000040137f <+71>:	jne    0x40136a <strings_not_equal+50>
     0x0000000000401381 <+73>:	mov    $0x0,%edx
     0x0000000000401386 <+78>:	jmp    0x40139b <strings_not_equal+99>
     0x0000000000401388 <+80>:	mov    $0x0,%edx
     0x000000000040138d <+85>:	jmp    0x40139b <strings_not_equal+99>
     0x000000000040138f <+87>:	mov    $0x1,%edx
     0x0000000000401394 <+92>:	jmp    0x40139b <strings_not_equal+99>
     0x0000000000401396 <+94>:	mov    $0x1,%edx
     0x000000000040139b <+99>:	mov    %edx,%eax
     0x000000000040139d <+101>:	pop    %rbx
     0x000000000040139e <+102>:	pop    %rbp
     0x000000000040139f <+103>:	pop    %r12
     0x00000000004013a1 <+105>:	ret
  End of assembler dump.
  (gdb) bt
  #0  0x0000000000401352 in strings_not_equal ()
  #1  0x0000000000400eee in phase_1 ()
  #2  0x0000000000400e3f in main (argc=<optimized out>, argv=<optimized out>) at bomb.c:74
  (gdb) p $r12d
  $3 = 43
  (gdb) p $eax
  $4 = 52
  (gdb) x/sb $rdi
  0x402400:	"Border relations with Canada have never been better."
  (gdb) q
  bash-5.1$ gdb -tui bomb
  bash-5.1$
  bash-5.1$ ./bomb
  Welcome to my fiendish little bomb. You have 6 phases with
  which to blow yourself up. Have a nice day!
  Border relations with Canada have never been better.
  Phase 1 defused. How about the next one?
#+end_example

Well, we have figured out the first bomb! Let's get moving to the next one!

** Bomb 2

As usual, we put the assembly code here:
#+begin_src asm
  0000000000400efc <phase_2>:
    400efc:	55                      push   %rbp
    400efd:	53                      push   %rbx
    400efe:	48 83 ec 28             sub    $0x28,%rsp
    400f02:	48 89 e6                mov    %rsp,%rsi
    400f05:	e8 52 05 00 00          callq  40145c <read_six_numbers>
    400f0a:	83 3c 24 01             cmpl   $0x1,(%rsp)
    400f0e:	74 20                   je     400f30 <phase_2+0x34>
    400f10:	e8 25 05 00 00          callq  40143a <explode_bomb>
    400f15:	eb 19                   jmp    400f30 <phase_2+0x34>
    400f17:	8b 43 fc                mov    -0x4(%rbx),%eax
    400f1a:	01 c0                   add    %eax,%eax
    400f1c:	39 03                   cmp    %eax,(%rbx)
    400f1e:	74 05                   je     400f25 <phase_2+0x29>
    400f20:	e8 15 05 00 00          callq  40143a <explode_bomb>
    400f25:	48 83 c3 04             add    $0x4,%rbx
    400f29:	48 39 eb                cmp    %rbp,%rbx
    400f2c:	75 e9                   jne    400f17 <phase_2+0x1b>
    400f2e:	eb 0c                   jmp    400f3c <phase_2+0x40>
    400f30:	48 8d 5c 24 04          lea    0x4(%rsp),%rbx
    400f35:	48 8d 6c 24 18          lea    0x18(%rsp),%rbp
    400f3a:	eb db                   jmp    400f17 <phase_2+0x1b>
    400f3c:	48 83 c4 28             add    $0x28,%rsp
    400f40:	5b                      pop    %rbx
    400f41:	5d                      pop    %rbp
    400f42:	c3                      retq

  000000000040145c <read_six_numbers>:
    40145c:	48 83 ec 18             sub    $0x18,%rsp
    401460:	48 89 f2                mov    %rsi,%rdx
    401463:	48 8d 4e 04             lea    0x4(%rsi),%rcx
    401467:	48 8d 46 14             lea    0x14(%rsi),%rax
    40146b:	48 89 44 24 08          mov    %rax,0x8(%rsp)
    401470:	48 8d 46 10             lea    0x10(%rsi),%rax
    401474:	48 89 04 24             mov    %rax,(%rsp)
    401478:	4c 8d 4e 0c             lea    0xc(%rsi),%r9
    40147c:	4c 8d 46 08             lea    0x8(%rsi),%r8
    401480:	be c3 25 40 00          mov    $0x4025c3,%esi
    401485:	b8 00 00 00 00          mov    $0x0,%eax
    40148a:	e8 61 f7 ff ff          callq  400bf0 <__isoc99_sscanf@plt>
    40148f:	83 f8 05                cmp    $0x5,%eax
    401492:	7f 05                   jg     401499 <read_six_numbers+0x3d>
    401494:	e8 a1 ff ff ff          callq  40143a <explode_bomb>
    401499:	48 83 c4 18             add    $0x18,%rsp
    40149d:	c3                      retq
#+end_src

The core of this function is:
#+begin_src asm
  0000000000400efc <phase_2>:
    400efe:	48 83 ec 28             sub    $0x28,%rsp
    400f02:	48 89 e6                mov    %rsp,%rsi
    400f05:	e8 52 05 00 00          callq  40145c <read_six_numbers>
    400f0a:	83 3c 24 01             cmpl   $0x1,(%rsp)
    400f0e:	74 20                   je     400f30 <phase_2+0x34>
    400f10:	e8 25 05 00 00          callq  40143a <explode_bomb>
    400f15:	eb 19                   jmp    400f30 <phase_2+0x34>
    400f17:	8b 43 fc                mov    -0x4(%rbx),%eax
    400f1a:	01 c0                   add    %eax,%eax
    400f1c:	39 03                   cmp    %eax,(%rbx)
    400f1e:	74 05                   je     400f25 <phase_2+0x29>
    400f20:	e8 15 05 00 00          callq  40143a <explode_bomb>
    400f25:	48 83 c3 04             add    $0x4,%rbx
    400f29:	48 39 eb                cmp    %rbp,%rbx
    400f2c:	75 e9                   jne    400f17 <phase_2+0x1b>
    400f2e:	eb 0c                   jmp    400f3c <phase_2+0x40>
    400f30:	48 8d 5c 24 04          lea    0x4(%rsp),%rbx
    400f35:	48 8d 6c 24 18          lea    0x18(%rsp),%rbp
    400f3a:	eb db                   jmp    400f17 <phase_2+0x1b>
#+end_src

And the trace path is:
#+begin_example
  400f0a -> 400f0e -> 400f30 -> 400f35 -> 400f3a ->
  400f17 -> 400f1a -> 400f1c -> 400f1e -> 400f25 ->
  400f29 -> 400f2c -> 400f17 -> ...(loop) -> 400f3c
#+end_example

phase-2's frame layout (in perspective of read_six_numbers):
#+CAPTION: phase-2's frame
| Address                    | Flow          |
|----------------------------+---------------|
| ...                        |               |
|----------------------------+---------------|
| 0x22(%rsi)                 |               |
|----------------------------+---------------|
| 0x18(%rsi)                 |               |
|----------------------------+---------------|
| 0x14(%rsi)                 |               |
|----------------------------+---------------|
| 0x10(%rsi)                 |               |
|----------------------------+---------------|
| 0xc(%rsi)                  | -> %r9        |
|----------------------------+---------------|
| 0x8(%rsi)                  | -> %r8        |
|----------------------------+---------------|
| 0x4(%rsi)                  | -> %rcx       |
|----------------------------+---------------|
| %rsi (%rsp of phase_2)     | -> %rdx       |
|----------------------------+---------------|
| 0x18(%rsp)                 |               |
|----------------------------+---------------|
| 0x14(%rsp)                 |               |
|----------------------------+---------------|
| 0x10(%rsp)                 |               |
|----------------------------+---------------|
| 0xc(%rsp)                  |               |
|----------------------------+---------------|
| 0x8(%rsp)                  | <- 0x14(%rsi) |
|----------------------------+---------------|
| 0x4(%rsp)                  |               |
|----------------------------+---------------|
| %rsp (of read_six_numbers) | <- 0x10(%rsi) |
|----------------------------+---------------|
| ...                        |               |

*Hint:*
#+begin_quote
1. An array will be allocated in =phase_2=, which is used to stored numbers used in context.\\
   After calling =read_six_numbers=, the array will be filled with *7* numbers.
2. There is a loop in =phase_2= function, that is used to check two *adjacent* arguments' correctness.
3. The first secret number have shown up in assembly code.
#+end_quote

** Bomb 3

Same as above:
#+begin_src asm
  0000000000400f43 <phase_3>:
    400f43:	48 83 ec 18             sub    $0x18,%rsp
    400f47:	48 8d 4c 24 0c          lea    0xc(%rsp),%rcx
    400f4c:	48 8d 54 24 08          lea    0x8(%rsp),%rdx
    400f51:	be cf 25 40 00          mov    $0x4025cf,%esi
    400f56:	b8 00 00 00 00          mov    $0x0,%eax
    400f5b:	e8 90 fc ff ff          callq  400bf0 <__isoc99_sscanf@plt>
    400f60:	83 f8 01                cmp    $0x1,%eax
    400f63:	7f 05                   jg     400f6a <phase_3+0x27>
    400f65:	e8 d0 04 00 00          callq  40143a <explode_bomb>
    400f6a:	83 7c 24 08 07          cmpl   $0x7,0x8(%rsp)
    400f6f:	77 3c                   ja     400fad <phase_3+0x6a>
    400f71:	8b 44 24 08             mov    0x8(%rsp),%eax
    400f75:	ff 24 c5 70 24 40 00    jmpq   *0x402470(,%rax,8)
    400f7c:	b8 cf 00 00 00          mov    $0xcf,%eax
    400f81:	eb 3b                   jmp    400fbe <phase_3+0x7b>
    400f83:	b8 c3 02 00 00          mov    $0x2c3,%eax
    400f88:	eb 34                   jmp    400fbe <phase_3+0x7b>
    400f8a:	b8 00 01 00 00          mov    $0x100,%eax
    400f8f:	eb 2d                   jmp    400fbe <phase_3+0x7b>
    400f91:	b8 85 01 00 00          mov    $0x185,%eax
    400f96:	eb 26                   jmp    400fbe <phase_3+0x7b>
    400f98:	b8 ce 00 00 00          mov    $0xce,%eax
    400f9d:	eb 1f                   jmp    400fbe <phase_3+0x7b>
    400f9f:	b8 aa 02 00 00          mov    $0x2aa,%eax
    400fa4:	eb 18                   jmp    400fbe <phase_3+0x7b>
    400fa6:	b8 47 01 00 00          mov    $0x147,%eax
    400fab:	eb 11                   jmp    400fbe <phase_3+0x7b>
    400fad:	e8 88 04 00 00          callq  40143a <explode_bomb>
    400fb2:	b8 00 00 00 00          mov    $0x0,%eax
    400fb7:	eb 05                   jmp    400fbe <phase_3+0x7b>
    400fb9:	b8 37 01 00 00          mov    $0x137,%eax
    400fbe:	3b 44 24 0c             cmp    0xc(%rsp),%eax
    400fc2:	74 05                   je     400fc9 <phase_3+0x86>
    400fc4:	e8 71 04 00 00          callq  40143a <explode_bomb>
    400fc9:	48 83 c4 18             add    $0x18,%rsp
    400fcd:	c3                      retq
#+end_src

*Hint*:
#+begin_quote
1. /0x4025cf/: This address have no meaning until in =__isoc99_sscanf@plt=, please p(rint) it!
2. /0x400f6a/: Limits the legitimate range of first argument(*index*). You should also take notice of =ja=.
2. /0x400f75/: This operation maybe a little hard to comprehend, just keeping in \\
             mind, it is *NOT* a single part but associated with following =jmp= segments.
3. All the legitimate first argument has it's corresponding result.
#+end_quote

** Bomb 4

Same as above:
#+begin_src asm
  0000000000400fce <func4>:
          ...

  000000000040100c <phase_4
    40100c:	48 83 ec 18             sub    $0x18,%rsp
    401010:	48 8d 4c 24 0c          lea    0xc(%rsp),%rcx
    401015:	48 8d 54 24 08          lea    0x8(%rsp),%rdx
    40101a:	be cf 25 40 00          mov    $0x4025cf,%esi
    40101f:	b8 00 00 00 00          mov    $0x0,%eax
    401024:	e8 c7 fb ff ff          callq  400bf0 <__isoc99_sscanf@plt>
    401029:	83 f8 02                cmp    $0x2,%eax
    40102c:	75 07                   jne    401035 <phase_4+0x29>
    40102e:	83 7c 24 08 0e          cmpl   $0xe,0x8(%rsp)
    401033:	76 05                   jbe    40103a <phase_4+0x2e>
    401035:	e8 00 04 00 00          callq  40143a <explode_bomb>
    40103a:	ba 0e 00 00 00          mov    $0xe,%edx
    40103f:	be 00 00 00 00          mov    $0x0,%esi
    401044:	8b 7c 24 08             mov    0x8(%rsp),%edi
    401048:	e8 81 ff ff ff          callq  400fce <func4>
    40104d:	85 c0                   test   %eax,%eax
    40104f:	75 07                   jne    401058 <phase_4+0x4c>
    401051:	83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)
    401056:	74 05                   je     40105d <phase_4+0x51>
    401058:	e8 dd 03 00 00          callq  40143a <explode_bomb>
    40105d:	48 83 c4 18             add    $0x18,%rsp
    401061:	c3                      retq
#+end_src

Interestingly, we can find that this function is somewhat different:
#+begin_src asm
  0000000000400fce <func4>:
    400fce:	48 83 ec 08             sub    $0x8,%rsp
    400fd2:	89 d0                   mov    %edx,%eax
    400fd4:	29 f0                   sub    %esi,%eax
    400fd6:	89 c1                   mov    %eax,%ecx
    400fd8:	c1 e9 1f                shr    $0x1f,%ecx
    400fdb:	01 c8                   add    %ecx,%eax
    400fdd:	d1 f8                   sar    %eax
    400fdf:	8d 0c 30                lea    (%rax,%rsi,1),%ecx
    400fe2:	39 f9                   cmp    %edi,%ecx
    400fe4:	7e 0c                   jle    400ff2 <func4+0x24>
    400fe6:	8d 51 ff                lea    -0x1(%rcx),%edx
    400fe9:	e8 e0 ff ff ff          callq  400fce <func4>
    400fee:	01 c0                   add    %eax,%eax
    400ff0:	eb 15                   jmp    401007 <func4+0x39>
    400ff2:	b8 00 00 00 00          mov    $0x0,%eax
    400ff7:	39 f9                   cmp    %edi,%ecx
    400ff9:	7d 0c                   jge    401007 <func4+0x39>
    400ffb:	8d 71 01                lea    0x1(%rcx),%esi
    400ffe:	e8 cb ff ff ff          callq  400fce <func4>
    401003:	8d 44 00 01             lea    0x1(%rax,%rax,1),%eax
    401007:	48 83 c4 08             add    $0x8,%rsp
    40100b:	c3                      retq
#+end_src

Notice:
#+begin_quote
1. From =phase-4='s calling, we can deduce that =func4= has three parameters.
2. The first argument we inputed is used as the first parameter here.
3. /0x400fe9/ and /0x400ffe/ indicate =func4= is a recursive function.
4. /0x400fe2/ and /0x400ff7/ make up the function exit.
#+end_quote

*Hint*:
#+begin_quote
1. =phase_4= needs two secret number(from /0x401029/).
2. The first argument is used in =func4=.
3. The second argument will be evaluated at /0x401051/.
#+end_quote

** Bomb 5

The complete part of code of phase-5:
#+begin_src asm
  0000000000401062 <phase_5>:
    401062:	53                      push   %rbx
    401063:	48 83 ec 20             sub    $0x20,%rsp
    401067:	48 89 fb                mov    %rdi,%rbx
    40106a:	64 48 8b 04 25 28 00    mov    %fs:0x28,%rax
    401071:	00 00
    401073:	48 89 44 24 18          mov    %rax,0x18(%rsp)
    401078:	31 c0                   xor    %eax,%eax
    40107a:	e8 9c 02 00 00          callq  40131b <string_length>
    40107f:	83 f8 06                cmp    $0x6,%eax
    401082:	74 4e                   je     4010d2 <phase_5+0x70>
    401084:	e8 b1 03 00 00          callq  40143a <explode_bomb>
    401089:	eb 47                   jmp    4010d2 <phase_5+0x70>
    40108b:	0f b6 0c 03             movzbl (%rbx,%rax,1),%ecx
    40108f:	88 0c 24                mov    %cl,(%rsp)
    401092:	48 8b 14 24             mov    (%rsp),%rdx
    401096:	83 e2 0f                and    $0xf,%edx
    401099:	0f b6 92 b0 24 40 00    movzbl 0x4024b0(%rdx),%edx
    4010a0:	88 54 04 10             mov    %dl,0x10(%rsp,%rax,1)
    4010a4:	48 83 c0 01             add    $0x1,%rax
    4010a8:	48 83 f8 06             cmp    $0x6,%rax
    4010ac:	75 dd                   jne    40108b <phase_5+0x29>
    4010ae:	c6 44 24 16 00          movb   $0x0,0x16(%rsp)
    4010b3:	be 5e 24 40 00          mov    $0x40245e,%esi
    4010b8:	48 8d 7c 24 10          lea    0x10(%rsp),%rdi
    4010bd:	e8 76 02 00 00          callq  401338 <strings_not_equal>
    4010c2:	85 c0                   test   %eax,%eax
    4010c4:	74 13                   je     4010d9 <phase_5+0x77>
    4010c6:	e8 6f 03 00 00          callq  40143a <explode_bomb>
    4010cb:	0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)
    4010d0:	eb 07                   jmp    4010d9 <phase_5+0x77>
    4010d2:	b8 00 00 00 00          mov    $0x0,%eax
    4010d7:	eb b2                   jmp    40108b <phase_5+0x29>
    4010d9:	48 8b 44 24 18          mov    0x18(%rsp),%rax
    4010de:	64 48 33 04 25 28 00    xor    %fs:0x28,%rax
    4010e5:	00 00
    4010e7:	74 05                   je     4010ee <phase_5+0x8c>
    4010e9:	e8 42 fa ff ff          callq  400b30 <__stack_chk_fail@plt>
    4010ee:	48 83 c4 20             add    $0x20,%rsp
    4010f2:	5b                      pop    %rbx
    4010f3:	c3                      retq
#+end_src

It's worth noting that the core of this function is:
#+begin_src asm
     0x000000000040108b <+41>:	movzbl (%rbx,%rax,1),%ecx
     0x000000000040108f <+45>:	mov    %cl,(%rsp)
     0x0000000000401092 <+48>:	mov    (%rsp),%rdx
     0x0000000000401096 <+52>:	and    $0xf,%edx
     0x0000000000401099 <+55>:	movzbl 0x4024b0(%rdx),%edx
     0x00000000004010a0 <+62>:	mov    %dl,0x10(%rsp,%rax,1)
     0x00000000004010a4 <+66>:	add    $0x1,%rax
     0x00000000004010a8 <+70>:	cmp    $0x6,%rax
     0x00000000004010ac <+74>:	jne    0x40108b <phase_5+41>
     0x00000000004010ae <+76>:	movb   $0x0,0x16(%rsp)
#+end_src

What does these codes do?
#+begin_quote
1. Load each *char* in string we inputed to register.
2. Do some magic mask on each char.
3. Transfer the masked char to specified continuous address(see below).
#+end_quote

Same as phase-2, here is the memory layout:
#+CAPTION: phase_5's frame
| Dest       | Src              |
|------------+------------------|
| 0x15(%rsp) | 0x5(%rbx) masked |
|------------+------------------|
| 0x14(%rsp) | 0x4(%rbx) masked |
|------------+------------------|
| 0x13(%rsp) | 0x3(%rbx) masked |
|------------+------------------|
| 0x12(%rsp) | 0x2(%rbx) masked |
|------------+------------------|
| 0x11(%rsp) | 0x1(%rbx) masked |
|------------+------------------|
| 0x10(%rsp) | 0x0(%rbx) masked |
|------------+------------------|

** Bomb 6

*Easy:*
#+name: phase6-preparation
#+begin_src asm
    401100:	49 89 e5                mov    %rsp,%r13
    401103:	48 89 e6                mov    %rsp,%rsi
    401106:	e8 51 03 00 00          callq  40145c <read_six_numbers>
    40110b:	49 89 e6                mov    %rsp,%r14
#+end_src
Nothing speical, just prepares some registers. Those registers will be
used in following parts.

*Medium:*
#+begin_src asm
    40110e:	41 bc 00 00 00 00       mov    $0x0,%r12d
    401114:	4c 89 ed                mov    %r13,%rbp
    401117:	41 8b 45 00             mov    0x0(%r13),%eax
    40111b:	83 e8 01                sub    $0x1,%eax
    40111e:	83 f8 05                cmp    $0x5,%eax
    401121:	76 05                   jbe    401128 <phase_6+0x34>
    401123:	e8 12 03 00 00          callq  40143a <explode_bomb>
    401128:	41 83 c4 01             add    $0x1,%r12d
    40112c:	41 83 fc 06             cmp    $0x6,%r12d
    401130:	74 21                   je     401153 <phase_6+0x5f>
    401132:	44 89 e3                mov    %r12d,%ebx
    401135:	48 63 c3                movslq %ebx,%rax
    401138:	8b 04 84                mov    (%rsp,%rax,4),%eax
    40113b:	39 45 00                cmp    %eax,0x0(%rbp)
    40113e:	75 05                   jne    401145 <phase_6+0x51>
    401140:	e8 f5 02 00 00          callq  40143a <explode_bomb>
    401145:	83 c3 01                add    $0x1,%ebx
    401148:	83 fb 05                cmp    $0x5,%ebx
    40114b:	7e e8                   jle    401135 <phase_6+0x41>
    40114d:	49 83 c5 04             add    $0x4,%r13
    401151:	eb c1                   jmp    401114 <phase_6+0x20>
#+end_src

Explanation:
#+begin_quote
1. As we can see, this whole part is a nested loop. It has two index counter:
   one is %r12d and another is %ebx.
2. In the outer loop, %r12d indicates the index of array of integers we inputed.
   In the inner loop, %ebx is used to check whether the index reach the end of
   the array.
3. %r13 is an */address/*, which embodies the element in the array of integers.
   It is initialized as the first number of the array.
   It can be incremented by 4(for it is an address).
4. The condition operations are /40111b and/ /40111e/. These two ops limit the
   numeric array must be greater than 0 and less than or equal to 6
   (/jbe/ is used to compare two unsigned integers!).
5. This nested loop is a bit like /bubble sort/, but internal functionality
   is a little different.
#+end_quote

*Easy:*
#+begin_src asm
    401153:	48 8d 74 24 18          lea    0x18(%rsp),%rsi
    401158:	4c 89 f0                mov    %r14,%rax
    40115b:	b9 07 00 00 00          mov    $0x7,%ecx
    401160:	89 ca                   mov    %ecx,%edx
    401162:	2b 10                   sub    (%rax),%edx
    401164:	89 10                   mov    %edx,(%rax)
    401166:	48 83 c0 04             add    $0x4,%rax
    40116a:	48 39 f0                cmp    %rsi,%rax
    40116d:	75 f1                   jne    401160 <phase_6+0x6c>
#+end_src

Explanation:
#+begin_quote
1. The whole part plays the role of an iterator.
2. %r14 is the first of array(think of /std::begin(arr)/ in cpp),
   and %rsi is a sentinel(/std::cend(arr)/).
3. This functionality is like [].map((x) => (7-x)).
#+end_quote

*Hard:*
#+begin_src asm
    40116f:	be 00 00 00 00          mov    $0x0,%esi
    401174:	eb 21                   jmp    401197 <phase_6+0xa3>
    401176:	48 8b 52 08             mov    0x8(%rdx),%rdx
    40117a:	83 c0 01                add    $0x1,%eax
    40117d:	39 c8                   cmp    %ecx,%eax
    40117f:	75 f5                   jne    401176 <phase_6+0x82>
    401181:	eb 05                   jmp    401188 <phase_6+0x94>
    401183:	ba d0 32 60 00          mov    $0x6032d0,%edx
    401188:	48 89 54 74 20          mov    %rdx,0x20(%rsp,%rsi,2)
    40118d:	48 83 c6 04             add    $0x4,%rsi
    401191:	48 83 fe 18             cmp    $0x18,%rsi
    401195:	74 14                   je     4011ab <phase_6+0xb7>
    401197:	8b 0c 34                mov    (%rsp,%rsi,1),%ecx
    40119a:	83 f9 01                cmp    $0x1,%ecx
    40119d:	7e e4                   jle    401183 <phase_6+0x8f>
    40119f:	b8 01 00 00 00          mov    $0x1,%eax
    4011a4:	ba d0 32 60 00          mov    $0x6032d0,%edx
    4011a9:	eb cb                   jmp    401176 <phase_6+0x82>
#+end_src

Explanation:
#+begin_quote
1. The nodus of this part is what does /0x6032d0/ mean. To make sense of
   this, we can use *disassemble* and *x* to look deep into it.
2. By analyzing address /0x6032d0/, we can find that it is a linked list.
   So this part puts each number to its corresponding postion of that
   structure.
3. *mov 0x8(%rdx),%rdx*? Think of */p = p->next/*.
4. *0x20(%rsp,%rsi,2)* and *add $0x4,%rsi* indicate the offset is 8.
5. This progress is loading each nubmer in turn into /$ecx/, and
   incremente *$eax*, meantime repeat the operation *mov 0x8(%rdx),%rdx*,
   until it can find the correct postion of current number in /$ecx/.
#+end_quote

Code in C:
#+begin_src c
  struct Node *p = node1;
  unsigned curr = input[1];

  if (curr == 1)
     ; // do something

  for (size_t i = 2; i <= 6; i++)
  {
     curr = input[i];
     for (size_t j = 1; j < curr; p = p->next, j++)
        ;  // work through
     // do something
  }
#+end_src

*Medium:*
#+begin_src asm
    4011ab:	48 8b 5c 24 20          mov    0x20(%rsp),%rbx
    4011b0:	48 8d 44 24 28          lea    0x28(%rsp),%rax
    4011b5:	48 8d 74 24 50          lea    0x50(%rsp),%rsi
    4011ba:	48 89 d9                mov    %rbx,%rcx
    4011bd:	48 8b 10                mov    (%rax),%rdx
    4011c0:	48 89 51 08             mov    %rdx,0x8(%rcx)
    4011c4:	48 83 c0 08             add    $0x8,%rax
    4011c8:	48 39 f0                cmp    %rsi,%rax
    4011cb:	74 05                   je     4011d2 <phase_6+0xde>
    4011cd:	48 89 d1                mov    %rdx,%rcx
    4011d0:	eb eb                   jmp    4011bd <phase_6+0xc9>
    4011d2:	48 c7 42 08 00 00 00    movq   $0x0,0x8(%rdx)
#+end_src

#+begin_quote
1. The value of /%rsi/ is equal to */std::cend()/*.
2. In this case, we need use *x/12xg $rsp+0x20* to dig out the regularity of it.
3. /mov/ and /lea/ is a bit different, so there exists /mov (%rax), $rcx/.
4. This part re-organize the linked list by changing the node field /next/
   to the address computed by our input.
5. /4011d2/ is setting NULL to /0x8(%rdx)/ (end of linked list).
#+end_quote

*Easy:*
#+begin_src asm
    4011da:	bd 05 00 00 00          mov    $0x5,%ebp
    4011df:	48 8b 43 08             mov    0x8(%rbx),%rax
    4011e3:	8b 00                   mov    (%rax),%eax
    4011e5:	39 03                   cmp    %eax,(%rbx)
    4011e7:	7d 05                   jge    4011ee <phase_6+0xfa>
    4011e9:	e8 4c 02 00 00          callq  40143a <explode_bomb>
    4011ee:	48 8b 5b 08             mov    0x8(%rbx),%rbx
    4011f2:	83 ed 01                sub    $0x1,%ebp
    4011f5:	75 e8                   jne    4011df <phase_6+0xeb>
#+end_src

#+begin_quote
1. /%rbx/ is equal to /0x20(%rsp)/ (the first node).
2. /%ebp/ is a index counter.
3. /4011df/ and /4011e3/ will compare the first column of following example, where
   the right answer hide in.
4. The answer should be converted to *7-x*.
#+end_quote

#+begin_example
(gdb) x/24xw 0x6032d0
0x6032d0 <node1>:	0x0000014c	0x00000001	0x006032e0	0x00000000
0x6032e0 <node2>:	0x000000a8	0x00000002	0x006032f0	0x00000000
0x6032f0 <node3>:	0x0000039c	0x00000003	0x00603300	0x00000000
0x603300 <node4>:	0x000002b3	0x00000004	0x00603320	0x00000000
0x603310 <node5>:	0x000001dd	0x00000005	0x00000000	0x00000000
0x603320 <node6>:	0x000001bb	0x00000006	0x00603310	0x00000000
#+end_example

** Secret bomb

Following is extracted from =bomb.s=:
#+begin_src asm
  0000000000401242 <secret_phase>:
    401242:	53                      push   %rbx
    401243:	e8 56 02 00 00          callq  40149e <read_line>
    401248:	ba 0a 00 00 00          mov    $0xa,%edx
    40124d:	be 00 00 00 00          mov    $0x0,%esi
    401252:	48 89 c7                mov    %rax,%rdi
    401255:	e8 76 f9 ff ff          callq  400bd0 <strtol@plt>
    40125a:	48 89 c3                mov    %rax,%rbx
    40125d:	8d 40 ff                lea    -0x1(%rax),%eax
    401260:	3d e8 03 00 00          cmp    $0x3e8,%eax
    401265:	76 05                   jbe    40126c <secret_phase+0x2a>
    401267:	e8 ce 01 00 00          callq  40143a <explode_bomb>
    40126c:	89 de                   mov    %ebx,%esi
    40126e:	bf f0 30 60 00          mov    $0x6030f0,%edi
    401273:	e8 8c ff ff ff          callq  401204 <fun7>
    401278:	83 f8 02                cmp    $0x2,%eax
    40127b:	74 05                   je     401282 <secret_phase+0x40>
    40127d:	e8 b8 01 00 00          callq  40143a <explode_bomb>
    401282:	bf 38 24 40 00          mov    $0x402438,%edi
    401287:	e8 84 f8 ff ff          callq  400b10 <puts@plt>
    40128c:	e8 33 03 00 00          callq  4015c4 <phase_defused>
    401291:	5b                      pop    %rbx
    401292:	c3                      retq
#+end_src

#+begin_quote
1. The secret bomb was not activated in normal procedure, but we have
   enough responsibility to defuse all the bombs for guaranteeing
   computers safe.
2. The bomb initializes after *initialize_bomb* called, so we need
   to put breakpoints after that.
3. There are some limitations on our input nubmer(see addr /401260/).
4. *fun7* must be return 2 for accomplishing this process in safety.
#+end_quote

The most difficult part of /secret_bomb/:
#+begin_src asm
  0000000000401204 <fun7>:
    401204:	48 83 ec 08             sub    $0x8,%rsp
    401208:	48 85 ff                test   %rdi,%rdi
    40120b:	74 2b                   je     401238 <fun7+0x34>
    40120d:	8b 17                   mov    (%rdi),%edx
    40120f:	39 f2                   cmp    %esi,%edx
    401211:	7e 0d                   jle    401220 <fun7+0x1c>
    401213:	48 8b 7f 08             mov    0x8(%rdi),%rdi
    401217:	e8 e8 ff ff ff          callq  401204 <fun7>
    40121c:	01 c0                   add    %eax,%eax
    40121e:	eb 1d                   jmp    40123d <fun7+0x39>
    401220:	b8 00 00 00 00          mov    $0x0,%eax
    401225:	39 f2                   cmp    %esi,%edx
    401227:	74 14                   je     40123d <fun7+0x39>
    401229:	48 8b 7f 10             mov    0x10(%rdi),%rdi
    40122d:	e8 d2 ff ff ff          callq  401204 <fun7>
    401232:	8d 44 00 01             lea    0x1(%rax,%rax,1),%eax
    401236:	eb 05                   jmp    40123d <fun7+0x39>
    401238:	b8 ff ff ff ff          mov    $0xffffffff,%eax
    40123d:	48 83 c4 08             add    $0x8,%rsp
    401241:	c3                      retq
#+end_src

Equivalent in pseudo code:
#+begin_src c
  // pseudo code, can not compile
  unsigned
  fun7((struct *) p, int n)
  {
    if (p == NULL)
      return -1;

    if (*p > n)
      return fun7(p + 0x8, n) << 1;
    else
      {
        if (*p == n)
          return 0;
        return fun7(p + 0x10, n) << 1 + 1;
      }
  }
#+end_src

*Hint:*
#+begin_quote
1. From above document, we have made sense of that *fun7* should return 2.
2. This is a recursion, so we should find the /base/ case first, then we
   can determine which branch should we go.
3. The effective trace is /401217 -> 401211 -> 401220 -> 40122d -> 401227 -> 40123d
   (pop stack this line) -> 401232 -> 40121c -> 401278/. There is only one solution
   to solve this problem.
4. Understanding how stack of recursive function was used is key point
   to work this out.
#+end_quote

What does data stored in */0x6030f0/* looks like?
#+begin_example
  (gdb) x/64xg 0x6030f0
  0x6030f0 <n1>:	0x0000000000000024	0x0000000000603110
  0x603100 <n1+16>:	0x0000000000603130	0x0000000000000000
  0x603110 <n21>:	0x0000000000000008	0x0000000000603190
  0x603120 <n21+16>:	0x0000000000603150	0x0000000000000000
  0x603130 <n22>:	0x0000000000000032	0x0000000000603170
  0x603140 <n22+16>:	0x00000000006031b0	0x0000000000000000
  0x603150 <n32>:	0x0000000000000016	0x0000000000603270
  0x603160 <n32+16>:	0x0000000000603230	0x0000000000000000
  0x603170 <n33>:	0x000000000000002d	0x00000000006031d0
  0x603180 <n33+16>:	0x0000000000603290	0x0000000000000000
  0x603190 <n31>:	0x0000000000000006	0x00000000006031f0
  0x6031a0 <n31+16>:	0x0000000000603250	0x0000000000000000
  0x6031b0 <n34>:	0x000000000000006b	0x0000000000603210
  0x6031c0 <n34+16>:	0x00000000006032b0	0x0000000000000000
  0x6031d0 <n45>:	0x0000000000000028	0x0000000000000000
  0x6031e0 <n45+16>:	0x0000000000000000	0x0000000000000000
  0x6031f0 <n41>:	0x0000000000000001	0x0000000000000000
  0x603200 <n41+16>:	0x0000000000000000	0x0000000000000000
  0x603210 <n47>:	0x0000000000000063	0x0000000000000000
  0x603220 <n47+16>:	0x0000000000000000	0x0000000000000000
  0x603230 <n44>:	0x0000000000000023	0x0000000000000000
  0x603240 <n44+16>:	0x0000000000000000	0x0000000000000000
  0x603250 <n42>:	0x0000000000000007	0x0000000000000000
  0x603260 <n42+16>:	0x0000000000000000	0x0000000000000000
  0x603270 <n43>:	0x0000000000000014	0x0000000000000000
  0x603280 <n43+16>:	0x0000000000000000	0x0000000000000000
  0x603290 <n46>:	0x000000000000002f	0x0000000000000000
  0x6032a0 <n46+16>:	0x0000000000000000	0x0000000000000000
  0x6032b0 <n48>:	0x00000000000003e9	0x0000000000000000
  0x6032c0 <n48+16>:	0x0000000000000000	0x0000000000000000
  0x6032d0 <node1>:	0x000000010000014c	0x00000000006032e0
  0x6032e0 <node2>:	0x00000002000000a8	0x00000000006032f0
#+end_example

Convert to a more understandable illustration:
#+begin_example
                      +------+
                      | 0x24 |
                      +------+
                     /        \
              +-----+         +------+
              | 0x8 |  bingo  | 0x32 |
              +-----+  /      +------+
             /      \ /       /       \
       +-----+   +------+    +------+   +------+
       | 0x6 |   | 0x16 |    | 0x2d |   | 0x6b |
       +-----+   +------+    +------+   +------+
       /   \     /      \     /     \     /    \
   +---+ +---+ +----+ +----+ +---+ +---+ +----+ +----+
   |0x1| |0x7| |0x23| |0x14| |0x1| |0x7| |0x23| |0x14|
   +---+ +---+ +----+ +----+ +---+ +---+ +----+ +----+
#+end_example

* Outro

After the lab, we should know how to use GDB for Reverse Engineering,
and make sense of how each type of data stored and accessed in
machine-level programming.
